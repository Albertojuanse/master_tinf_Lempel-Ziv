function decodificadorLZ78_Sebastian_Lombranna_Alberto(filenameInputCompressed,filenameOutputUncompressed)
%DECODIFICADORLZ78_SEBASTIAN_LOMBRANNA_ALBERTO This decoder implements the Lempel-Ziv 78 algorithm

%% Retrieve information from ASCII input
% The coder ensures that an byte-even number of bits are used; count them.
input_file_id = fopen(filenameInputCompressed, 'r');
[i, count] = fread(input_file_id,'ubit8');
input_size_bits = count * 8;        % Size of the input in bits

%% Other variables
dictionary = {};                    % Dictionary
total_bits = 0;                     % Bits of the file already readed

%% 

%input_file_id = fopen(filenameInputCompressed, 'r');
%input = [];
%input = [input fread(input_file_id, 1, 'ubit1')];
%input = [input fread(input_file_id, 1, 'ubit8')];
%input = [input fread(input_file_id, 1, 'ubit2')];
%input = [input fread(input_file_id, 1, 'ubit8')];
%input = [input fread(input_file_id, 1, 'ubit2')];
%input = [input fread(input_file_id, 1, 'ubit8')];
%input = [input fread(input_file_id, 1, 'ubit3')];
%input = [input fread(input_file_id, 1, 'ubit8')];
%input = [input fread(input_file_id, 1, 'ubit3')];
%input = [input fread(input_file_id, 1, 'ubit8')];
%input = [input fread(input_file_id, 1, 'ubit3')];
%input = [input fread(input_file_id, 1, 'ubit8')];
%input = [input fread(input_file_id, 1, 'ubit3')];
%input = [input fread(input_file_id, 1, 'ubit8')];
%input = [input fread(input_file_id, 1, 'ubit8')]
%input = [1 116 2 117 1 117 4 118 3 118 6 119 7 120 3];

%% Execution
input_file_id = fopen(filenameInputCompressed, 'r');
output_file_id = fopen(filenameOutputUncompressed, 'a');

output = [];

% For every bit in the file
while 1
    
    % Each codeword is the composite of the dictionary entry index and the
    % next character
    dictionary_size = size(dictionary,1);
    
    % Precision needed to decodify the dictionary next entry; when the
    % codeword is coded, the dictionary have an extra entry there.
    next_size_dictionary = size(dictionary,1) + 1;
    next_size_dictionary_bin = dec2bin(next_size_dictionary);
    next_num_bits = size(next_size_dictionary_bin,2);
    precision = strcat('ubit',num2str(next_num_bits));

    % Retrieve the dictionary index
    i_entry_retrieved = fread(input_file_id, 1, precision);
    
    % The character is always saved with precision 'ubit8'
    entry_retrieved = fread(input_file_id, 1, 'ubit8');
    
    % If the entry exists in the dictionary, use it; if not, create it
    % before use it.
    if i_entry_retrieved > dictionary_size
        dictionary{end + 1,1} = [entry_retrieved];
        fwrite(output_file_id, [output; entry_retrieved],'ubit8');
    else
        entry_found = dictionary{i_entry_retrieved};
        dictionary{end + 1,1} = [entry_found entry_retrieved];
        fwrite(output_file_id, [output; transpose(entry_found); entry_retrieved],'ubit8');
    end
    
    % Count the bits retrieved
    total_bits = total_bits + next_num_bits + 8;

    % Verify if the file is reaching its end.
    % If the file is reaching its end, the codification was different; the
    % number of bits needed for the real dictionary index and the rest
    % until raach even-byte file.
    % This following lines calculates the bits saved in the file when the 
    % last codeword was generated by the coder; break the while loop if the
    % number of bits is equals to the ones left in the file.
    next_size_dictionary = size(dictionary,1);
    next_size_dictionary_bin = dec2bin(next_size_dictionary);
    next_num_bits = size(next_size_dictionary_bin,2);
    next_total_bits = total_bits + next_num_bits;
    next_odd_bits = mod(next_total_bits,8);
    if next_odd_bits == 0
        % Just 8 bits
    else
        next_bits_left = 8 - next_odd_bits;
        next_total_bits = next_total_bits + next_bits_left;
    end
    
    if next_total_bits == input_size_bits
        break;
    end

end

% The while loop breaked because there is only one codeword left; must
% retrieve that one
% Same routine one last time



% Precision needed to decodify the dictionary next entry; when the
% codeword is coded, the dictionary have an extra entry there.
dictionary_size = size(dictionary,1);
next_size_dictionary = size(dictionary,1) + 1;
next_size_dictionary_bin = dec2bin(next_size_dictionary);
next_num_bits = size(next_size_dictionary_bin,2);
next_total_bits = total_bits + next_num_bits;
next_odd_bits = mod(next_total_bits,8);
if next_odd_bits == 0
    % Just 8 bits
    precision = strcat('ubit',num2str(next_num_bits));
    
else
    next_bits_left = 8 - next_odd_bits;
    precision = strcat('ubit',num2str(next_num_bits + next_bits_left));
    next_total_bits = next_total_bits + next_bits_left;
end

% Retrieve the dictionary index
i_entry_retrieved = fread(input_file_id, 1, precision);

entry_retrieved = fread(input_file_id, 1, 'ubit8');

% If the entry exists in the dictionary, use it; if not, create it
% before use it.
if i_entry_retrieved > dictionary_size
    % ERROR; CAN'T HAPPEN
    fwrite(output_file_id, [69; 82; 82; 79; 82],'ubit8');
else    
    entry_found = dictionary{i_entry_retrieved};
    dictionary{end + 1,1} = [entry_found entry_retrieved];
    fwrite(output_file_id, [output; transpose(entry_found); entry_retrieved],'ubit8');
end

% Count the bits retrieved
total_bits = next_total_bits;

%% Close input and output files
fclose(input_file_id);
fclose(output_file_id);

end